'''
특징만 알면 풀 수 있는 문제이다.
n의 최대값이 10,000인 걸 보고 반복문이나 완전탐색 같은걸론 안되겠다 싶었다.
예시를 보니 2,9 이면 4,5 | 2,8이면 4,4 뭔가 느낌이 오는데
우선 divmod(9,2) 해보면 몫이 4 나머지가 1이 나온다.
그럼 [4,5]가 [4, 4+1]인 걸 알 수 있다.
키포인트는 n이 2일때는 그렇지만 n이 3 이상일경우는 예를들어
3,10이면 divmod(10,3) -> 3, 1이 나오는데 [3,3,4]로 구성해야 가장 큰 값을 얻을 수 있다.
여기서 [3,3,(3+1)]이 되는건데 만약 나머지가 2 이상일경우에는 [3,(3+1), (3+1)]로 구성해야 더 큰값을 얻을 수 있다.
따라서 맨 끝 값만 늘리는게 아닌, 골고루 늘려야 가장 큰 값을 얻을 수 있다.
'''
def solution(n,s):

    a,b = divmod(s,n)
    ans=[a]*n
    if a==0:
        return [-1]

    for i in range(b):
        ans[i]+=1

    return ans[::-1]

n=2
s=9

n=2
s=8

n=3
s=10
print(solution(n,s))